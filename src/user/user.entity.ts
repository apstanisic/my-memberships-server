import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  Unique,
  UpdateDateColumn,
  CreateDateColumn,
  ManyToOne,
  ManyToMany
} from 'typeorm';
import { SerializeOptions } from '@nestjs/common';
import {
  IsEmail,
  validate,
  IsNotEmpty,
  MinLength,
  ValidationError
} from 'class-validator';
import * as bcrypt from 'bcryptjs';
import { Exclude } from 'class-transformer';
import BaseException from '../core/BaseException';
import uuid from 'uuid';
import { ObjectType, Field, ID } from 'type-graphql';
import { Subscription } from 'src/subscription/subscription.entity';
import { Company } from 'src/gym/company.entity';
import { isBcryptHash } from 'src/core/helpers';

@ObjectType()
@Entity('users')
@Unique(['email'])
@SerializeOptions({ enableCircularCheck: true })
export class User {
  /* Autogenerated unique ID */
  @Field(type => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  /* Companies where this user is owner */
  @ManyToOne(type => Company, comp => comp.owner)
  @Field(type => [Company])
  ownedCompanies: Company[];

  /* All companies where this user is admin */
  @ManyToMany(type => Company, comp => comp.admins)
  companiesWhereAdmin: Company[];

  /* Every subscription user have or had in the past */
  @Column()
  @Field(type => [Subscription])
  @ManyToOne(type => Subscription, sub => sub.owner)
  subscriptions: Subscription[];

  /* User Email, has to be unique and to be valid email */
  @Column()
  @Field()
  @IsEmail()
  email: string;

  /* Password has at least 6 chars. It's cached with bcrypt. It won't be returned */
  @Column()
  @IsNotEmpty()
  @MinLength(6)
  @Exclude()
  password: string;

  /* User real name */
  @Field()
  @Column()
  name: string;

  /* User's profile picture */
  @Column({ nullable: true })
  @Field()
  avatar?: string;

  /* Users phone number. It's not required */
  @Field({ nullable: true })
  @Column({ nullable: true })
  phoneNumber?: string;

  /* Did user confirm his account */
  @Column({ default: false })
  @Exclude()
  confirmed: boolean;

  /* Can be used to confirm user, reset password, etc... */
  @Column({ nullable: true })
  @Exclude()
  secureToken?: string;

  /*
  Time when secureToken was created.
  Server can then decide for how long shoud token be valid
  */
  @Column({ nullable: true })
  @Exclude()
  tokenCreatedAt?: Date;

  /* When was user last updated */
  @UpdateDateColumn()
  @Exclude()
  updatedAt: Date;

  /* When was user created */
  @CreateDateColumn()
  @Exclude()
  createdAt: Date;

  /* Check if provided password is valid */
  comparePassword(enteredPassword: string): Promise<boolean> {
    return bcrypt.compare(enteredPassword, this.password);
  }

  /* Change user password. This will hash password */
  async setPassword(password: string) {
    this.password = await bcrypt.hash(password, 12);
  }

  /* Generate secure token to be used for password reset... */
  generateSecureToken() {
    this.secureToken = uuid();
    this.tokenCreatedAt = new Date();
  }

  /* Check if all fields are valid */
  async validate() {
    const error = await validate(this);
    // Password must be hashed with bcrypt. If not throw error
    if (!isBcryptHash(this.password)) {
      console.error(
        `Password almost passed unhashed! Attempted user: ${this.email}`
      );

      const hashError = new ValidationError();
      hashError.constraints['Invalid password'] =
        'Password problem. Please contact us.';
      hashError.target = 'password';

      error.push(hashError);
    }
    if (error.length > 0) throw new BaseException({ error });
  }
}
